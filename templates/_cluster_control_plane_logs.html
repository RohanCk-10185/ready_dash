<!-- Control Plane Logs Tab -->
<div id="control-plane-logs" class="tab-content">
    <style>
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        #control-plane-logs.fade-in {
            animation: fadeIn 0.3s ease-in-out;
        }
        
        /* Control Plane Logs Styles */
        .control-plane-logs-container {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .logs-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .logs-header h4 {
            margin: 0;
            color: var(--text-primary);
            font-size: 1.1rem;
            font-weight: 600;
        }
        
        
        .logs-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
        }
        
        @media (max-width: 1200px) {
            .logs-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        @media (max-width: 768px) {
            .logs-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .log-metric-card {
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 2rem;
            position: relative;
            min-height: 320px;
        }
        
        .log-metric-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .log-metric-header h5 {
            margin: 0;
            color: var(--text-primary);
            font-size: 1.1rem;
            font-weight: 600;
        }
        
        .log-metric-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        .info-icon, .more-icon {
            width: 16px;
            height: 16px;
            color: var(--text-secondary);
            cursor: pointer;
            position: relative;
        }
        
        .info-icon:hover, .more-icon:hover {
            color: var(--text-primary);
        }
        
        .tooltip {
            position: relative;
            display: inline-block;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: var(--text-primary);
            color: var(--bg-color);
            text-align: center;
            border-radius: 4px;
            padding: 8px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            font-size: 0.8rem;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: var(--text-primary) transparent transparent transparent;
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        
        
        .log-metric-chart {
            height: 220px;
            margin-bottom: 0.5rem;
        }
        
        .log-metric-legend {
            font-size: 0.75rem;
            color: var(--text-secondary);
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            background: var(--bg-secondary);
            padding: 0.4rem 0.6rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            word-break: break-all;
            line-height: 1.3;
            margin-top: 0.5rem;
        }
        
        .logs-loading, .logs-error {
            text-align: center;
            padding: 2rem;
            color: var(--text-secondary);
        }
        
        .loading-spinner {
            width: 24px;
            height: 24px;
            border: 2px solid var(--border-color);
            border-top: 2px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .logs-error {
            color: var(--status-failed);
        }
    </style>

    <h3 class="section-title">Control Plane Monitoring</h3>
    <div class="control-plane-logs-container">
        <div class="logs-header">
            <h4>API Server Request Metrics</h4>
        </div>
        
        <div class="logs-grid">
            <div class="log-metric-card">
                <div class="log-metric-header">
                    <h5>Requests</h5>
                    <div class="log-metric-actions">
                        <div class="tooltip">
                            <i data-feather="info" class="info-icon"></i>
                            <span class="tooltiptext">The number of HTTP requests made across all the API servers in the cluster.</span>
                        </div>
                    </div>
                </div>
                <div class="log-metric-chart">
                    <canvas id="requestsChartTab"></canvas>
                </div>
                <div class="log-metric-legend">apiserver_request_total</div>
            </div>
            
            <div class="log-metric-card">
                <div class="log-metric-header">
                    <h5>Requests HTTP 4XX</h5>
                    <div class="log-metric-actions">
                        <div class="tooltip">
                            <i data-feather="info" class="info-icon"></i>
                            <span class="tooltiptext">The number of HTTP requests made to all the API servers in the cluster that resulted in 4XX (client error) status codes.</span>
                        </div>
                    </div>
                </div>
                <div class="log-metric-chart">
                    <canvas id="requests4XXChartTab"></canvas>
                </div>
                <div class="log-metric-legend">apiserver_request_total_4XX</div>
            </div>
            
            <div class="log-metric-card">
                <div class="log-metric-header">
                    <h5>Requests HTTP 5XX</h5>
                    <div class="log-metric-actions">
                        <div class="tooltip">
                            <i data-feather="info" class="info-icon"></i>
                            <span class="tooltiptext">The number of HTTP requests made to all the API servers in the cluster that resulted in 5XX (server error) status codes.</span>
                        </div>
                    </div>
                </div>
                <div class="log-metric-chart">
                    <canvas id="requests5XXChartTab"></canvas>
                </div>
                <div class="log-metric-legend">apiserver_request_total_5XX</div>
            </div>
            
            <div class="log-metric-card">
                <div class="log-metric-header">
                    <h5>Requests HTTP 429</h5>
                    <div class="log-metric-actions">
                        <div class="tooltip">
                            <i data-feather="info" class="info-icon"></i>
                            <span class="tooltiptext">The number of HTTP requests made to all the API servers in the cluster lat resulted in 429 status code, which occurs when clients exceed the rate limiting thresholds.</span>
                        </div>
                    </div>
                </div>
                <div class="log-metric-chart">
                    <canvas id="requests429ChartTab"></canvas>
                </div>
                <div class="log-metric-legend">apiserver_request_total_429</div>
            </div>
            
            <div class="log-metric-card">
                <div class="log-metric-header">
                    <h5>Storage Size Bytes</h5>
                    <div class="log-metric-actions">
                        <div class="tooltip">
                            <i data-feather="info" class="info-icon"></i>
                            <span class="tooltiptext">The physical size in bytes of the etcd storage database file used by the API servers in the cluster. This metric represents the actual disk space allocated for the storage.</span>
                        </div>
                    </div>
                </div>
                <div class="log-metric-chart">
                    <canvas id="storageSizeChartTab"></canvas>
                </div>
                <div class="log-metric-legend">apiserver_storage_size_bytes</div>
            </div>
            
            <div class="log-metric-card">
                <div class="log-metric-header">
                    <h5>Scheduler Attempts</h5>
                    <div class="log-metric-actions">
                        <div class="tooltip">
                            <i data-feather="info" class="info-icon"></i>
                            <span class="tooltiptext">The number of scheduling attempts made by the Kubernetes scheduler. Shows successful scheduling attempts (SCHEDULED), failed attempts due to resource constraints (UNSCHEDULABLE), and errors (ERROR).</span>
                        </div>
                    </div>
                </div>
                <div class="log-metric-chart">
                    <canvas id="schedulerAttemptsChartTab"></canvas>
                </div>
                <div class="log-metric-legend">scheduler_schedule_attempts_SCHEDULED</div>
            </div>
            
            <div class="log-metric-card">
                <div class="log-metric-header">
                    <h5>Pending Pods</h5>
                    <div class="log-metric-actions">
                        <div class="tooltip">
                            <i data-feather="info" class="info-icon"></i>
                            <span class="tooltiptext">The number of pods in different pending states in the scheduler queue. Shows GATED (waiting for conditions), UNSCHEDULABLE (cannot be scheduled), ACTIVEQ (active queue), and BACKOFF (retry with backoff).</span>
                        </div>
                    </div>
                </div>
                <div class="log-metric-chart">
                    <canvas id="pendingPodsChartTab"></canvas>
                </div>
                <div class="log-metric-legend">scheduler_pending_pods_GATED</div>
            </div>
            
            <div class="log-metric-card">
                <div class="log-metric-header">
                    <h5>API Server Request Latency</h5>
                    <div class="log-metric-actions">
                        <div class="tooltip">
                            <i data-feather="info" class="info-icon"></i>
                            <span class="tooltiptext">P99 latency for different HTTP methods (GET, POST, PUT, DELETE) to the API server. Higher values indicate slower response times.</span>
                        </div>
                    </div>
                </div>
                <div class="log-metric-chart">
                    <canvas id="apiLatencyChartTab"></canvas>
                </div>
                <div class="log-metric-legend" id="apiLatencyLegend">apiserver_request_duration_seconds_GET_P99</div>
            </div>
            
            <div class="log-metric-card">
                <div class="log-metric-header">
                    <h5>API Server Current Inflight Requests</h5>
                    <div class="log-metric-actions">
                        <div class="tooltip">
                            <i data-feather="info" class="info-icon"></i>
                            <span class="tooltiptext">Current number of inflight requests being processed by the API server. Shows MUTATING (write operations) and READONLY (read operations) requests.</span>
                        </div>
                    </div>
                </div>
                <div class="log-metric-chart">
                    <canvas id="apiInflightChartTab"></canvas>
                </div>
                <div class="log-metric-legend" id="apiInflightLegend">apiserver_current_inflight_requests_MUTATING</div>
            </div>
            
        </div>
        
        <div class="logs-loading" id="controlPlaneLogsLoadingTab" style="display: none;">
            <div class="loading-spinner"></div>
            <p>Loading control plane logs...</p>
        </div>
        
        <div class="logs-error" id="controlPlaneLogsErrorTab" style="display: none;">
            <p>Failed to load control plane logs. Please try again.</p>
        </div>
    </div>
</div>

<script>
    let controlPlaneLogsCharts = {};
    
    window.addEventListener('load', () => {
        const tab = document.getElementById('control-plane-logs');
        if (tab) {
            tab.classList.add('fade-in');
        }
        initializeControlPlaneLogs();
    });
    
    function initializeControlPlaneLogs() {
        // Load initial data
        loadControlPlaneLogs();
    }
    
    async function loadControlPlaneLogs() {
        const loadingEl = document.getElementById('controlPlaneLogsLoadingTab');
        const errorEl = document.getElementById('controlPlaneLogsErrorTab');
        const logsContainer = document.querySelector('.control-plane-logs-container');
        
        // Show loading state
        loadingEl.style.display = 'block';
        errorEl.style.display = 'none';
        logsContainer.style.display = 'none';
        
        try {
            const response = await fetch(`/api/control-plane-logs/{{ cluster.account_id }}/{{ cluster.region }}/{{ cluster.name }}`);
            const data = await response.json();
            
            if (data.error) {
                throw new Error(data.error);
            }
            
            // Debug logging for scheduler metrics (can be removed in production)
            if (data.scheduler_schedule_attempts_SCHEDULED) {
                console.log('Scheduler SCHEDULED data received:', data.scheduler_schedule_attempts_SCHEDULED);
            }
            
            // Hide loading, show data
            loadingEl.style.display = 'none';
            logsContainer.style.display = 'block';
            
            // Update charts
            updateControlPlaneLogsCharts(data);
            
        } catch (error) {
            console.error('Error loading control plane logs:', error);
            loadingEl.style.display = 'none';
            errorEl.style.display = 'block';
        }
    }
    
    function updateControlPlaneLogsCharts(data) {
        // Update Requests chart
        updateLogChart('requestsChartTab', data.apiserver_request_total, 'Requests');
        
        // Update 4XX Requests chart
        updateLogChart('requests4XXChartTab', data.apiserver_request_total_4XX, '4XX Requests');
        
        // Update 5XX Requests chart
        updateLogChart('requests5XXChartTab', data.apiserver_request_total_5XX, '5XX Requests');
        
        // Update 429 Requests chart
        updateLogChart('requests429ChartTab', data.apiserver_request_total_429, '429 Requests');
        
        // Update Storage Size chart
        updateLogChart('storageSizeChartTab', data.apiserver_storage_size_bytes, 'Storage Size Bytes');
        
        // Update Scheduler Attempts chart
        updateSchedulerChart('schedulerAttemptsChartTab', data);
        
        // Update Pending Pods chart
        updatePendingPodsChart('pendingPodsChartTab', data);
        
        // Update API Server Request Latency chart
        updateApiLatencyChart('apiLatencyChartTab', data);
        
        // Update API Server Current Inflight Requests chart
        updateApiInflightChart('apiInflightChartTab', data);
        
    }
    
    function updateLogChart(canvasId, metricData, title) {
        if (!metricData || !metricData.values || metricData.values.length === 0) {
            return;
        }
        
        // Get or create chart
        const canvas = document.getElementById(canvasId);
        const ctx = canvas.getContext('2d');
        
        // Destroy existing chart if it exists
        if (controlPlaneLogsCharts[canvasId]) {
            controlPlaneLogsCharts[canvasId].destroy();
        }
        
        // Prepare data
        const timestamps = metricData.timestamps.map(ts => new Date(ts));
        const values = metricData.values;
        
        // Create new chart
        controlPlaneLogsCharts[canvasId] = new Chart(ctx, {
            type: 'line',
            data: {
                labels: timestamps,
                datasets: [{
                    label: title,
                    data: values,
                    borderColor: '#0D6EFD',
                    backgroundColor: 'rgba(13, 110, 253, 0.1)',
                    borderWidth: 1.5,
                    fill: true,
                    tension: 0.1,
                    pointRadius: 0,
                    pointHoverRadius: 4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            displayFormats: {
                                hour: 'HH:mm'
                            }
                        },
                        grid: {
                            display: false
                        },
                        ticks: {
                            maxTicksLimit: 6
                        }
                    },
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.1)'
                        },
                        ticks: {
                            callback: function(value) {
                                return formatValue(value);
                            }
                        }
                    }
                },
                interaction: {
                    intersect: false,
                    mode: 'index'
                }
            }
        });
    }
    
    function updateSchedulerChart(canvasId, data) {
        // Get or create chart
        const canvas = document.getElementById(canvasId);
        const ctx = canvas.getContext('2d');
        
        // Destroy existing chart if it exists
        if (controlPlaneLogsCharts[canvasId]) {
            controlPlaneLogsCharts[canvasId].destroy();
        }
        
        // Prepare datasets for all scheduler metrics
        const datasets = [];
        const colors = {
            'SCHEDULED': '#0D6EFD',
            'UNSCHEDULABLE': '#FFC107', 
            'ERROR': '#DC3545'
        };
        
        // Add SCHEDULED metric (primary)
        if (data.scheduler_schedule_attempts_SCHEDULED && data.scheduler_schedule_attempts_SCHEDULED.values && data.scheduler_schedule_attempts_SCHEDULED.values.length > 0) {
            const timestamps = data.scheduler_schedule_attempts_SCHEDULED.timestamps.map(ts => new Date(ts));
            datasets.push({
                label: 'SCHEDULED',
                data: data.scheduler_schedule_attempts_SCHEDULED.values,
                borderColor: colors.SCHEDULED,
                backgroundColor: 'rgba(13, 110, 253, 0.1)',
                borderWidth: 1.5,
                fill: false,
                tension: 0.1,
                pointRadius: 0,
                pointHoverRadius: 4
            });
        }
        
        // Add UNSCHEDULABLE metric (if available)
        if (data.scheduler_schedule_attempts_UNSCHEDULABLE && data.scheduler_schedule_attempts_UNSCHEDULABLE.values && data.scheduler_schedule_attempts_UNSCHEDULABLE.values.length > 0) {
            const timestamps = data.scheduler_schedule_attempts_UNSCHEDULABLE.timestamps.map(ts => new Date(ts));
            datasets.push({
                label: 'UNSCHEDULABLE',
                data: data.scheduler_schedule_attempts_UNSCHEDULABLE.values,
                borderColor: colors.UNSCHEDULABLE,
                backgroundColor: 'rgba(255, 193, 7, 0.1)',
                borderWidth: 1.5,
                fill: false,
                tension: 0.1,
                pointRadius: 0,
                pointHoverRadius: 4
            });
        }
        
        // Add ERROR metric (if available)
        if (data.scheduler_schedule_attempts_ERROR && data.scheduler_schedule_attempts_ERROR.values && data.scheduler_schedule_attempts_ERROR.values.length > 0) {
            const timestamps = data.scheduler_schedule_attempts_ERROR.timestamps.map(ts => new Date(ts));
            datasets.push({
                label: 'ERROR',
                data: data.scheduler_schedule_attempts_ERROR.values,
                borderColor: colors.ERROR,
                backgroundColor: 'rgba(220, 53, 69, 0.1)',
                borderWidth: 1.5,
                fill: false,
                tension: 0.1,
                pointRadius: 0,
                pointHoverRadius: 4
            });
        }
        
        // If no data available, show a message
        if (datasets.length === 0) {
            // Create a simple chart with "No Data" message
            controlPlaneLogsCharts[canvasId] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: ['No Data Available'],
                    datasets: [{
                        label: 'SCHEDULED',
                        data: [0],
                        borderColor: colors.SCHEDULED,
                        backgroundColor: 'rgba(13, 110, 253, 0.1)',
                        borderWidth: 1.5,
                        fill: false,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                usePointStyle: true,
                                padding: 20
                            }
                        },
                        title: {
                            display: true,
                            text: 'Scheduler metrics not available in CloudWatch',
                            font: {
                                size: 12,
                                color: '#666'
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: false
                        },
                        y: {
                            display: false
                        }
                    }
                }
            });
            return;
        }
        
        // Use timestamps from the first available dataset
        const firstDataset = datasets[0];
        const timestamps = data.scheduler_schedule_attempts_SCHEDULED ? 
            data.scheduler_schedule_attempts_SCHEDULED.timestamps.map(ts => new Date(ts)) :
            (data.scheduler_schedule_attempts_UNSCHEDULABLE ? 
                data.scheduler_schedule_attempts_UNSCHEDULABLE.timestamps.map(ts => new Date(ts)) :
                data.scheduler_schedule_attempts_ERROR.timestamps.map(ts => new Date(ts)));
        
        // Create new chart
        controlPlaneLogsCharts[canvasId] = new Chart(ctx, {
            type: 'line',
            data: {
                labels: timestamps,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        position: 'bottom',
                        labels: {
                            usePointStyle: true,
                            padding: 20
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            displayFormats: {
                                hour: 'HH:mm'
                            }
                        },
                        grid: {
                            display: false
                        },
                        ticks: {
                            maxTicksLimit: 6
                        }
                    },
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.1)'
                        },
                        ticks: {
                            callback: function(value) {
                                return formatValue(value);
                            }
                        }
                    }
                },
                interaction: {
                    intersect: false,
                    mode: 'index'
                }
            }
        });
    }
    
    function updatePendingPodsChart(canvasId, data) {
        // Get or create chart
        const canvas = document.getElementById(canvasId);
        const ctx = canvas.getContext('2d');
        
        // Destroy existing chart if it exists
        if (controlPlaneLogsCharts[canvasId]) {
            controlPlaneLogsCharts[canvasId].destroy();
        }
        
        // Prepare datasets for all pending pods metrics
        const datasets = [];
        const colors = {
            'GATED': '#0D6EFD',        // Blue
            'UNSCHEDULABLE': '#FFC107', // Orange
            'ACTIVEQ': '#198754',       // Green
            'BACKOFF': '#DC3545'        // Red
        };
        
        // Add GATED metric (primary)
        if (data.scheduler_pending_pods_GATED && data.scheduler_pending_pods_GATED.values && data.scheduler_pending_pods_GATED.values.length > 0) {
            datasets.push({
                label: 'GATED',
                data: data.scheduler_pending_pods_GATED.values,
                borderColor: colors.GATED,
                backgroundColor: 'rgba(13, 110, 253, 0.1)',
                borderWidth: 1.5,
                fill: false,
                tension: 0.1,
                pointRadius: 0,
                pointHoverRadius: 4
            });
        }
        
        // Add UNSCHEDULABLE metric
        if (data.scheduler_pending_pods_UNSCHEDULABLE && data.scheduler_pending_pods_UNSCHEDULABLE.values && data.scheduler_pending_pods_UNSCHEDULABLE.values.length > 0) {
            datasets.push({
                label: 'UNSCHEDULABLE',
                data: data.scheduler_pending_pods_UNSCHEDULABLE.values,
                borderColor: colors.UNSCHEDULABLE,
                backgroundColor: 'rgba(255, 193, 7, 0.1)',
                borderWidth: 1.5,
                fill: false,
                tension: 0.1,
                pointRadius: 0,
                pointHoverRadius: 4
            });
        }
        
        // Add ACTIVEQ metric
        if (data.scheduler_pending_pods_ACTIVEQ && data.scheduler_pending_pods_ACTIVEQ.values && data.scheduler_pending_pods_ACTIVEQ.values.length > 0) {
            datasets.push({
                label: 'ACTIVEQ',
                data: data.scheduler_pending_pods_ACTIVEQ.values,
                borderColor: colors.ACTIVEQ,
                backgroundColor: 'rgba(25, 135, 84, 0.1)',
                borderWidth: 1.5,
                fill: false,
                tension: 0.1,
                pointRadius: 0,
                pointHoverRadius: 4
            });
        }
        
        // Add BACKOFF metric
        if (data.scheduler_pending_pods_BACKOFF && data.scheduler_pending_pods_BACKOFF.values && data.scheduler_pending_pods_BACKOFF.values.length > 0) {
            datasets.push({
                label: 'BACKOFF',
                data: data.scheduler_pending_pods_BACKOFF.values,
                borderColor: colors.BACKOFF,
                backgroundColor: 'rgba(220, 53, 69, 0.1)',
                borderWidth: 1.5,
                fill: false,
                tension: 0.1,
                pointRadius: 0,
                pointHoverRadius: 4
            });
        }
        
        // If no data available, show a message
        if (datasets.length === 0) {
            // Create a simple chart with "No Data" message
            controlPlaneLogsCharts[canvasId] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: ['No Data Available'],
                    datasets: [{
                        label: 'GATED',
                        data: [0],
                        borderColor: colors.GATED,
                        backgroundColor: 'rgba(13, 110, 253, 0.1)',
                        borderWidth: 1.5,
                        fill: false,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                usePointStyle: true,
                                padding: 20
                            }
                        },
                        title: {
                            display: true,
                            text: 'Pending pods metrics not available in CloudWatch',
                            font: {
                                size: 12,
                                color: '#666'
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: false
                        },
                        y: {
                            display: false
                        }
                    }
                }
            });
            return;
        }
        
        // Use timestamps from the first available dataset
        const timestamps = data.scheduler_pending_pods_GATED ? 
            data.scheduler_pending_pods_GATED.timestamps.map(ts => new Date(ts)) :
            (data.scheduler_pending_pods_UNSCHEDULABLE ? 
                data.scheduler_pending_pods_UNSCHEDULABLE.timestamps.map(ts => new Date(ts)) :
                (data.scheduler_pending_pods_ACTIVEQ ? 
                    data.scheduler_pending_pods_ACTIVEQ.timestamps.map(ts => new Date(ts)) :
                    data.scheduler_pending_pods_BACKOFF.timestamps.map(ts => new Date(ts))));
        
        // Create new chart
        controlPlaneLogsCharts[canvasId] = new Chart(ctx, {
            type: 'line',
            data: {
                labels: timestamps,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        position: 'bottom',
                        labels: {
                            usePointStyle: true,
                            padding: 20
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            displayFormats: {
                                hour: 'HH:mm'
                            }
                        },
                        grid: {
                            display: false
                        },
                        ticks: {
                            maxTicksLimit: 6
                        }
                    },
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.1)'
                        },
                        ticks: {
                            callback: function(value) {
                                return formatValue(value);
                            }
                        }
                    }
                },
                interaction: {
                    intersect: false,
                    mode: 'index'
                }
            }
        });
    }
    
    function updateApiLatencyChart(canvasId, data) {
        // Get or create chart
        const canvas = document.getElementById(canvasId);
        const ctx = canvas.getContext('2d');
        
        // Destroy existing chart if it exists
        if (controlPlaneLogsCharts[canvasId]) {
            controlPlaneLogsCharts[canvasId].destroy();
        }
        
        // Prepare datasets for all latency metrics
        const datasets = [];
        const colors = {
            'GET': '#4cccff',     // Blue
            'POST': '#f6933d',    // Orange
            'PUT': '#7ded7f',     // Green
            'DELETE': '#ff5757',  // Red
            'LIST': '#7577ff',    // Purple
            'PATCH': '#7b4e2a'    // Brown/Orange
        };
        
        // Add GET latency metric
        if (data.apiserver_request_duration_seconds_GET_P99 && data.apiserver_request_duration_seconds_GET_P99.values && data.apiserver_request_duration_seconds_GET_P99.values.length > 0) {
            datasets.push({
                label: 'GET P99',
                data: data.apiserver_request_duration_seconds_GET_P99.values,
                borderColor: colors.GET,
                backgroundColor: 'rgba(13, 110, 253, 0.1)',
                borderWidth: 1.5,
                fill: false,
                tension: 0.1,
                pointRadius: 0,
                pointHoverRadius: 4
            });
        }
        
        // Add POST latency metric
        if (data.apiserver_request_duration_seconds_POST_P99 && data.apiserver_request_duration_seconds_POST_P99.values && data.apiserver_request_duration_seconds_POST_P99.values.length > 0) {
            datasets.push({
                label: 'POST P99',
                data: data.apiserver_request_duration_seconds_POST_P99.values,
                borderColor: colors.POST,
                backgroundColor: 'rgba(255, 193, 7, 0.1)',
                borderWidth: 1.5,
                fill: false,
                tension: 0.1,
                pointRadius: 0,
                pointHoverRadius: 4
            });
        }
        
        // Add PUT latency metric
        if (data.apiserver_request_duration_seconds_PUT_P99 && data.apiserver_request_duration_seconds_PUT_P99.values && data.apiserver_request_duration_seconds_PUT_P99.values.length > 0) {
            datasets.push({
                label: 'PUT P99',
                data: data.apiserver_request_duration_seconds_PUT_P99.values,
                borderColor: colors.PUT,
                backgroundColor: 'rgba(25, 135, 84, 0.1)',
                borderWidth: 1.5,
                fill: false,
                tension: 0.1,
                pointRadius: 0,
                pointHoverRadius: 4
            });
        }
        
        // Add DELETE latency metric
        if (data.apiserver_request_duration_seconds_DELETE_P99 && data.apiserver_request_duration_seconds_DELETE_P99.values && data.apiserver_request_duration_seconds_DELETE_P99.values.length > 0) {
            datasets.push({
                label: 'DELETE P99',
                data: data.apiserver_request_duration_seconds_DELETE_P99.values,
                borderColor: colors.DELETE,
                backgroundColor: 'rgba(111, 66, 193, 0.1)',
                borderWidth: 1.5,
                fill: false,
                tension: 0.1,
                pointRadius: 0,
                pointHoverRadius: 4
            });
        }
        
        // Add LIST latency metric
        if (data.apiserver_request_duration_seconds_LIST_P99 && data.apiserver_request_duration_seconds_LIST_P99.values && data.apiserver_request_duration_seconds_LIST_P99.values.length > 0) {
            datasets.push({
                label: 'LIST P99',
                data: data.apiserver_request_duration_seconds_LIST_P99.values,
                borderColor: colors.LIST,
                backgroundColor: 'rgba(111, 66, 193, 0.1)',
                borderWidth: 1.5,
                fill: false,
                tension: 0.1,
                pointRadius: 0,
                pointHoverRadius: 4
            });
        }
        
        // Add PATCH latency metric
        if (data.apiserver_request_duration_seconds_PATCH_P99 && data.apiserver_request_duration_seconds_PATCH_P99.values && data.apiserver_request_duration_seconds_PATCH_P99.values.length > 0) {
            datasets.push({
                label: 'PATCH P99',
                data: data.apiserver_request_duration_seconds_PATCH_P99.values,
                borderColor: colors.PATCH,
                backgroundColor: 'rgba(253, 126, 20, 0.1)',
                borderWidth: 1.5,
                fill: false,
                tension: 0.1,
                pointRadius: 0,
                pointHoverRadius: 4
            });
        }
        
        // If no data available, show a message
        if (datasets.length === 0) {
            controlPlaneLogsCharts[canvasId] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: ['No Data Available'],
                    datasets: [{
                        label: 'GET P99',
                        data: [0],
                        borderColor: colors.GET,
                        backgroundColor: 'rgba(13, 110, 253, 0.1)',
                        borderWidth: 1.5,
                        fill: false,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                usePointStyle: true,
                                padding: 20
                            }
                        },
                        title: {
                            display: true,
                            text: 'API server latency metrics not available in CloudWatch',
                            font: {
                                size: 12,
                                color: '#666'
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: false
                        },
                        y: {
                            display: false
                        }
                    }
                }
            });
            return;
        }
        
        // Use timestamps from the first available dataset
        const timestamps = data.apiserver_request_duration_seconds_GET_P99 ? 
            data.apiserver_request_duration_seconds_GET_P99.timestamps.map(ts => new Date(ts)) :
            (data.apiserver_request_duration_seconds_POST_P99 ? 
                data.apiserver_request_duration_seconds_POST_P99.timestamps.map(ts => new Date(ts)) :
                (data.apiserver_request_duration_seconds_PUT_P99 ? 
                    data.apiserver_request_duration_seconds_PUT_P99.timestamps.map(ts => new Date(ts)) :
                    (data.apiserver_request_duration_seconds_DELETE_P99 ? 
                        data.apiserver_request_duration_seconds_DELETE_P99.timestamps.map(ts => new Date(ts)) :
                        (data.apiserver_request_duration_seconds_LIST_P99 ? 
                            data.apiserver_request_duration_seconds_LIST_P99.timestamps.map(ts => new Date(ts)) :
                            data.apiserver_request_duration_seconds_PATCH_P99.timestamps.map(ts => new Date(ts))))));
        
        // Update legend with all variable values
        const legendElement = document.getElementById('apiLatencyLegend');
        if (legendElement) {
            const variableNames = datasets.map(dataset => dataset.label).join(', ');
            legendElement.textContent = variableNames;
        }
        
        // Create new chart
        controlPlaneLogsCharts[canvasId] = new Chart(ctx, {
            type: 'line',
            data: {
                labels: timestamps,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false  // Hide chart legend since we show it below
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            displayFormats: {
                                hour: 'HH:mm'
                            }
                        },
                        grid: {
                            display: false
                        },
                        ticks: {
                            maxTicksLimit: 6
                        }
                    },
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.1)'
                        },
                        ticks: {
                            callback: function(value) {
                                return value.toFixed(3) + 's';
                            }
                        }
                    }
                },
                interaction: {
                    intersect: false,
                    mode: 'index'
                }
            }
        });
    }
    
    function updateApiInflightChart(canvasId, data) {
        // Get or create chart
        const canvas = document.getElementById(canvasId);
        const ctx = canvas.getContext('2d');
        
        // Destroy existing chart if it exists
        if (controlPlaneLogsCharts[canvasId]) {
            controlPlaneLogsCharts[canvasId].destroy();
        }
        
        // Prepare datasets for inflight requests metrics
        const datasets = [];
        const colors = {
            'MUTATING': '#4cccff',  // Blue
            'READONLY': '#ff7300'   // Orange
        };
        
        // Add MUTATING requests metric
        if (data.apiserver_current_inflight_requests_MUTATING && data.apiserver_current_inflight_requests_MUTATING.values && data.apiserver_current_inflight_requests_MUTATING.values.length > 0) {
            datasets.push({
                label: 'MUTATING',
                data: data.apiserver_current_inflight_requests_MUTATING.values,
                borderColor: colors.MUTATING,
                backgroundColor: 'rgba(13, 110, 253, 0.1)',
                borderWidth: 1.5,
                fill: false,
                tension: 0.1,
                pointRadius: 0,
                pointHoverRadius: 4
            });
        }
        
        // Add READONLY requests metric
        if (data.apiserver_current_inflight_requests_READONLY && data.apiserver_current_inflight_requests_READONLY.values && data.apiserver_current_inflight_requests_READONLY.values.length > 0) {
            datasets.push({
                label: 'READONLY',
                data: data.apiserver_current_inflight_requests_READONLY.values,
                borderColor: colors.READONLY,
                backgroundColor: 'rgba(255, 193, 7, 0.1)',
                borderWidth: 1.5,
                fill: false,
                tension: 0.1,
                pointRadius: 0,
                pointHoverRadius: 4
            });
        }
        
        // If no data available, show a message
        if (datasets.length === 0) {
            controlPlaneLogsCharts[canvasId] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: ['No Data Available'],
                    datasets: [{
                        label: 'MUTATING',
                        data: [0],
                        borderColor: colors.MUTATING,
                        backgroundColor: 'rgba(13, 110, 253, 0.1)',
                        borderWidth: 1.5,
                        fill: false,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                usePointStyle: true,
                                padding: 20
                            }
                        },
                        title: {
                            display: true,
                            text: 'API server inflight requests metrics not available in CloudWatch',
                            font: {
                                size: 12,
                                color: '#666'
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: false
                        },
                        y: {
                            display: false
                        }
                    }
                }
            });
            return;
        }
        
        // Use timestamps from the first available dataset
        const timestamps = data.apiserver_current_inflight_requests_MUTATING ? 
            data.apiserver_current_inflight_requests_MUTATING.timestamps.map(ts => new Date(ts)) :
            data.apiserver_current_inflight_requests_READONLY.timestamps.map(ts => new Date(ts));
        
        // Update legend with all variable values
        const legendElement = document.getElementById('apiInflightLegend');
        if (legendElement) {
            const variableNames = datasets.map(dataset => dataset.label).join(', ');
            legendElement.textContent = variableNames;
        }
        
        // Create new chart
        controlPlaneLogsCharts[canvasId] = new Chart(ctx, {
            type: 'line',
            data: {
                labels: timestamps,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false  // Hide chart legend since we show it below
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            displayFormats: {
                                hour: 'HH:mm'
                            }
                        },
                        grid: {
                            display: false
                        },
                        ticks: {
                            maxTicksLimit: 6
                        }
                    },
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.1)'
                        },
                        ticks: {
                            callback: function(value) {
                                return formatValue(value);
                            }
                        }
                    }
                },
                interaction: {
                    intersect: false,
                    mode: 'index'
                }
            }
        });
    }
    
    function formatValue(value) {
        if (value >= 1000000) {
            return (value / 1000000).toFixed(1) + 'M';
        } else if (value >= 1000) {
            return (value / 1000).toFixed(1) + 'k';
        } else if (value < 1 && value > 0) {
            return value.toFixed(3);
        } else {
            return Math.round(value).toString();
        }
    }
</script>
